3 章 クラス設計-すべてにつながる設計の基盤-
保守や変更がしやすいコードを書くには、関心の分離が重要である。

- 不変で思わぬ動作を防ぐ
  変数に値が再代入されると、値がいつ変更されたのかや今どのような値が入っているかが追いづらい。
  その結果、仕様が変わった場合に意図しない値に書き変わってしまういわゆる「副作用」を起こし兼ねない。
  これを防止するために、インスタンス変数やメソッドの引数を不変（イミュータブル）にすることを検討する。
  もし、値を変更したくなったら値を変更した新しいインスタンスを生成する。

- 値オブジェクト
  値オブジェクトとは、値の概念そのものをクラスとして表現することである。
  例えば、お金を表したい時には「BigDecimal」を利用するのではなく（内部的には利用するかもしれないが）、「Money」クラスを自分で作成するべし。
  こうすることで、誤って異なる BigDecimal 型の変数をメソッドの引数に渡してしまったり、お金に関連するロジックが複数箇所に散らばってしまうことを未然に防ぐことができる。

5 章 低凝集-バラバラになったモノたち-

凝集度とは、モジュール内におけるデータとロジックの関係性の強さのことである。
ここでいうモジュールとはクラス、パッケージ、レイヤーなどさまざまな粒度があるが、クラスとして話を進める。

凝集度の低いクラスとは、データとロジックの関係性が弱いクラスのことである。
低凝集なクラスはデータとロジックが散らばっているため、変更に弱い。
一方で、高凝集なクラスはデータとロジックがまとまっているため、変更に強い設計であるといえる。

- static メソッドはデータとロジックを分離してしまう。
  static なメソッドはインスタンス変数を使うことができないため、データ（インスタンス変数）とそれを操作するロジックが乖離してしまう。
  従って、可能であればインスタンスメソッドで代替できないか検討する。
  ただし、static なメソッドが有効なケースもある。
  例えば、横断的に使用するログ出力用のメソッドやファクトリメソッドなど凝集度を意識する必要がない場面では検討するべし。

6 章 条件分岐-迷宮化した分岐処理を解きほぐす手法-

- ネストについて考える
  条件がネストされていると仕様を把握しづらい。
  また、if 文が更に必要になった場合にネストがまた深くなってしまうだろう。
  そこで、条件を満たしていない場合はただちに return で抜けてしまう早期 return を検討すると良い。

- enum を使う前に考えたいこと
  同種類の特徴を持つ複数のモデルに各々の振る舞いを持たせたい場合、よく enum と switch 文の組み合わせが用いられる。
  しかし、enum と switch 文の組み合わせには、複数のデメリットがある。
  - 同じ条件の switch 文が複数書かれていく。
  - case 文を追加漏れが起こりうる。

そこで、interface の導入を検討する。
interface の最大のメリットは、分岐処理を書かずに機能の切り替えを実装することができることである。
また、実装クラスで interface を implements していればコンパイラが自動的に未実装箇所を教えてくれるので、仕様変更時の実装漏れも起こりにくい。
(その他、ネストした if 文を interface で解決する設計パターンとして、ポリシーパターンというのも紹介されていました。)

9 章 設計の健全性をそこなう様々な悪魔たち

- null 問題
  null はさまざまな問題を起こしうる。
  従って、「null を返さない。渡さない」ようにすることを検討する。
  例えば、値がないことを表現したい場合、static final な変数の利用（Money クラスなら、Money.ZERO や Money.Empty など）を検討する。

- 例外の握り潰し
  例外を握りつぶしてしまうと、外から内部の不正な状態を検知する術がなくなります。
  従って、問題を検出した場合は握り潰さず、即座に検知できる仕組みを作ることを検討する。

最後に、
「ソフトウェア開発に銀の弾丸はない。設計に best はない。常に better を目指しましょう。」
